"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()

"""
The work required to handle all interaction in a custom manner is... outragus. 
As such I am going to work with input() and make it pretty

The End Is Nigh

-Your Fearless Leader
"""

import os
import msvcrt
import random
import keyboard
import time
import sys
import ctypes
from llama_cpp import Llama
import pyperclip
import threading

class AI:
	def __init__(self):
		mdl = "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf" # "Llama-3.2-1B-Instruct-Q4_K_M.gguf" # "veryunsafellama3.2-1b.gguf" # "Llama-3.2-3B-Instruct-uncensored-Q4_K_M.gguf"
		self.model = Llama(model_path=mdl, n_ctx=4096, n_threads=8)
		with open("systPrompt.txt", "r") as f:
			self.systPrompt = f.read()
	
	def getResponse(self, messages):
		
		prompt = ""
		for msg in messages:
			prompt += "<|start_header_id|>"+msg["speaker"]+"<|end_header_id|>\n\n"+msg["text"]+"<|eot_id|>"
		prompt += "<|start_header_id|>assistant<|end_header_id|>\n\n"
		prompt = prompt.replace("SYSTEMPROMPT", self.systPrompt)
		
		response = self.model(prompt, max_tokens=8196)["choices"][0]["text"].replace("\n", " ") # we replace all \n with " " because of reasons...
		
		return response

class CLI:
	def __init__(self):
		self.ai = AI()
		
		self.id = 0
		self.selectedId = -1
		
		STD_OUTPUT_HANDLE = -11
		self.console_handle = ctypes.windll.kernel32.GetStdHandle(STD_OUTPUT_HANDLE)
		
		self.mainLoop()
	
	def set_cursor_position(self, x, y):
		"""Moves the cursor to the specified (x, y) position in the console."""
		position = (y << 16) | x  # COORD structure: LOWORD = x, HIWORD = y
		ctypes.windll.kernel32.SetConsoleCursorPosition(self.console_handle, position)
	
		
	def splitByWidth(self, text, width):
		out = [""]
		
		for i in text:
			if i == "\n":
				out.append("")
				continue
			
			out[-1] += i
			if len(out[-1]) == width:
				out.append("")
				continue
		
		return out
	
	def drawMessage(self, msg, outline, alignSide=True):
		if outline:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u259B", "\u259C", "\u2599", "\u259F", "\u2500", "\u2502"]
		else:
			topLeft, topRight, bottomLeft, bottomRight, horz, vert = ["\u256D", "\u256E", "\u2570", "\u256F", "\u2500", "\u2502"]
		
		frnt = ""
		
		if msg["speaker"] == "user" and alignSide:
			frnt = " " * 20
		
		amnt = 22 if alignSide else 2
		
		print(frnt+topLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(topRight)
		
		lines = self.splitByWidth(msg["text"], self.width-amnt)
		
		for line in lines:
			print(frnt+vert+line+" "*(self.width-len(line)-amnt)+vert+"\n", end="")
		
		print(frnt+bottomLeft, end="")
		print(horz*(self.width-amnt), end="")
		print(bottomRight)
		
		return outline
	
	def printMessages(self, outline):
		if self.rootMessage == None:
			print("NO MESSAGES\n")
			return
		
		lft = -1
		msg = self.rootMessage
		while True:
			lft -= 1
			if lft == 0:
				print("MORE NOT DISPLAYED")
				return
			
			stopHere = self.drawMessage(msg, (msg["id"] == self.selectedId and outline), alignSide=msg["speaker"]!="system")
			if stopHere:
				lft = 3
			
			if msg["selectedChild"] == -1:
				break
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findById(self, id):
		msg = self.rootMessage
		if msg == None:
			return None
		
		while True:
			if msg["id"] == id:
				return msg
			
			msg = msg["children"][msg["selectedChild"]]
	
	def redraw(self):
		os.system("cls") # clear terminal
		
		size = os.get_terminal_size() # get current size
		width = size.columns
		self.width = width
		
		if self.state=="Message Menu":
			msg = self.findById(self.selectedId)
			self.drawMessage(msg, False, alignSide=False)
			print()
			
			self.numButtons = 5
			for indx, b in enumerate(["Previous", "Next", "Edit", "Branch", "Regenerate"]):
				if indx == self.selectedButton:
					print(" \u2588"+b+"\u2588 ", end="")
				else:
					print(" "+b+" ", end="")
			
			print()
			
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
		
		# Print the messages
		
		self.printMessages(self.state!="Writing Message")
		
		if self.state=="Writing Message":
			print("\u2588"*width)
			
			instruction = input(">>> ")
			
			return instruction, instruction == ""
		elif self.state=="Selecting Message":
			while True:
				if msvcrt.kbhit():
					key = msvcrt.getch()  # Read key (single byte)
					
					if key == b'\r':  # Enter key
						return "Exec", True
					elif key == b'\x1b':
						return "", True
					
					elif key == b'\xe0':  # Arrow keys and other special keys
						key2 = msvcrt.getch()  # Get second byte
			
						if key2 == b'H':  # Up Arrow
							return "Up", True
						elif key2 == b'P':  # Down Arrow
							return "Down", True
						elif key2 == b'K':  # Left Arrow
							return "Left", True
						elif key2 == b'M':  # Right Arrow
							return "Right", True
	
	def insertChildNode(self, node):
		self.selectedId = node["id"]
		
		msg = self.rootMessage
		if msg == None:
			self.rootMessage = node
			return
		
		while True:
			if msg["selectedChild"] == -1:
				msg["children"].append(node)
				msg["selectedChild"] = len(msg["children"])-1
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def collectMessages(self):
		msg = self.rootMessage
		if msg == None:
			return []
		
		msgs = []
		
		while True:
			msgs.append({"speaker":msg["speaker"], "text":msg["text"]})
			if msg["selectedChild"] == -1:
				return msgs
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def findPrevId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					return msg["id"]
				msg = next
	
	def findNextId(self):
		msg = self.rootMessage
		if msg == None:
			return self.selectedId
		
		while True:
			if msg["selectedChild"] == -1:
				return self.selectedId
			else:
				next = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					return next["id"]
				msg = next
	
	def sendMessage(self, message):
		msg = self.createMessage(message, "user")
		self.insertChildNode(msg)
		respText = self.ai.getResponse(self.collectMessages())
		rsp = self.createMessage(respText, "assistant")
		self.insertChildNode(rsp)
	
	def createMessage(self, text, speaker):
		self.id += 1
		return {"text":text, "children":[], "selectedChild":-1, "speaker":speaker, "id":self.id}
	
	def prev(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] -= 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def next(self):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					msg["selectedChild"] += 1
					msg["selectedChild"] %= len(msg["children"])
					self.selectedId = msg["children"][msg["selectedChild"]]["id"]
					return
				msg = next
	
	def changeText(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
				if msg["id"] == self.selectedId:
					msg["text"] = newText
					return
	
	def branch(self, newText):
		msg = self.rootMessage
		if msg == None:
			return
		
		while True:
			if msg["selectedChild"] == -1:
				return
			else:
				next = msg["children"][msg["selectedChild"]]
				if next["id"] == self.selectedId:
					newNode = self.createMessage(newText, next["speaker"])
					msg["children"].append(newNode)
					msg["selectedChild"] = len(msg["children"])-1
					keeper = self.id
					if newNode["speaker"] == "user":
						respText = self.ai.getResponse(self.collectMessages())
						rsp = self.createMessage(respText, "assistant")
						self.insertChildNode(rsp)
					self.selectedId = keeper
					return
				msg = next
	
	def findBottomId(self):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["selectedChild"] == -1:
				return msg["id"]
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def setNodesChild(self, newChild):
		msg = self.rootMessage
		if msg == None:
			return -1
		
		while True:
			if msg["id"] == self.selectedId:
				msg["selectedChild"] = newChild
				return
			else:
				msg = msg["children"][msg["selectedChild"]]
	
	def mainLoop(self):
		self.state = "Writing Message"
		self.currentMessage = ""
		self.rootMessage = self.createMessage("SYSTEMPROMPT", "system")
		
		while True:
			instruction, special = self.redraw()
			if not special and instruction != "":
				self.sendMessage(instruction)
			elif special:
				if self.state == "Writing Message":
					self.state = "Selecting Message"
					self.selectedId = self.findBottomId()
				elif self.state == "Selecting Message":
					if instruction == "" and special:
						self.state = "Writing Message"
					elif instruction == "Exec":
						self.state = "Message Menu"
						self.selectedButton = 0
					elif instruction == "Up":
						self.selectedId = self.findPrevId()
					elif instruction == "Down":
						self.selectedId = self.findNextId()
				elif self.state == "Message Menu":
					if instruction == "Left":
						self.selectedButton -= 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Right":
						self.selectedButton += 1
						self.selectedButton  %= self.numButtons
					elif instruction == "Exec":
						# self.selectedButton # "Previous", "Next", "Edit", "Branch", "Regenerate"
						if self.selectedButton == 0:
							self.prev()
						elif self.selectedButton == 1:
							self.next()
						elif self.selectedButton == 2:
							print()
							pyperclip.copy(self.findById(self.selectedId)["text"])
							print("Copied to clipboard.")
							print()
							newTxt = input(">>> ")
							self.changeText(newTxt)
						elif self.selectedButton == 3:
							print()
							newTxt = input(">>> ")
							self.branch(newTxt)
						elif self.selectedButton == 4:
							self.selectedId = self.findPrevId()
							self.setNodesChild(-1)
							respText = self.ai.getResponse(self.collectMessages())
							rsp = self.createMessage(respText, "assistant")
							self.insertChildNode(rsp)
							self.state = "Writing Message"
						
					elif instruction == "" and special:
						self.state = "Selecting Message"

cli = CLI()